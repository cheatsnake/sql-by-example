# SQL на примерах

SQL (Structured Query Language) – это специальный язык запросов для работы с реляционными базами данных (например [MySQL](https://ru.wikipedia.org/wiki/MySQL), [PostgreSQL](https://ru.wikipedia.org/wiki/PostgreSQL), [Oracle](https://ru.wikipedia.org/wiki/Oracle_Database), [MariaDB](https://ru.wikipedia.org/wiki/MariaDB)). SQL-запросы строятся из набора операторов, которые представляют из себя обычные слова английского языка.

> Все приведенные примеры были успешно протестированы в PostgreSQL версии 15.

- [Основы SQL](#основы-sql)
  - [Создание новой базы данных](#создание-новой-базы-данных)
  - [Создание таблицы](#создание-таблицы)
  - [Типы данных](#типы-данных)
      - [Числовые типы](#числовые-типы)
      - [Символьные типы](#символьные-типы)
      - [Дата и время](#дата-и-время)
      - [Геометрические типы](#геометрические-типы)
      - [Другие](#другие)
  - [Атрибуты](#атрибуты)
  - [Добавление данных](#добавление-данных)
  - [Выборка данных](#выборка-данных)
  - [Поиск данных по шаблону](#поиск-данных-по-шаблону)
  - [Сортировка данных](#сортировка-данных)
  - [Изменение данных](#изменение-данных)
  - [Удаление данных](#удаление-данных)
  - [Псевдонимы](#псевдонимы)
  - [Изменение таблиц](#изменение-таблиц)
  - [Агрегатные функции](#агрегатные-функции)
  - [Группировка данных](#группировка-данных)
- [Индексы](#индексы)
  - [Создание индекса](#создание-индекса)
  - [Удаление индекса](#удаление-индекса)
  - [Типы индексов](#типы-индексов)
  - [Составные индексы](#составные-индексы)
  - [Индексы для выражений](#индексы-для-выражений)

## Основы SQL

В данном разделе рассматриваются примеры основных операций (созданиe/получениe/изменениe/удалениe) для работы с данными в SQL-таблицах.

### Создание новой базы данных

```sql
CREATE DATABASE store;
```

В базе данных можно определять неограниченное количество таблиц в которых и будут хранится нужные данные.

> Заметьте, что каждый SQL-запрос заканчивается точкой с запятой.

### Создание таблицы

На этапе создания таблицы указываются типы данных и определяются различные атрибуты для всех столбцов.

```sql
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    firstName VARCHAR(50) NOT NULL,
    lastName VARCHAR(50) NOT NULL,
    email VARCHAR(50) UNIQUE,
    phone VARCHAR(20) UNIQUE,
    age SMALLINT NOT NULL,
    gender VARCHAR(6) NOT NULL,
    isMarried BOOLEAN,
    createdAt TIMESTAMP,
    updatedAt TIMESTAMP
);
```

### Типы данных

Ниже приведен список основных типов для базы данных PostgreSQL.

> В других СУБД приведенные типы данных и их описание может немного отличаться. Поэтому при возникновении ошибок обратитесь к документации.

#### Числовые типы

| Тип                         | Значения                                                              | Описание                                                                                                                                                       |
| :-------------------------- | :-------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `smallint` `int2`           | Числа от -32768 до +32767                                             | Занимает 2 байта.                                                                                                                                              |
| `integer` `int4` `int`      | Числа от -2147483648 до +2147483647                                   | Занимает 4 байта.                                                                                                                                              |
| `bigint` `int8`             | Числа от -9223372036854775808 до +9223372036854775807                 | Занимает 8 байт.                                                                                                                                               |
| `numeric` `decimal`         | Числа с целой часть до 131072 знаков и до 131072 знаков после запятой | Принимает 2 параметра precision (общее количество цифр) и scale (количество цифр после запятой). <br> _numeric(5, 3) – 22,725_ <br> _decimal(10, 1) – 52538,4_ |
| `real` `float4`             | Числа от 1E-37 до 1E+37                                               | Занимает 4 байта.                                                                                                                                              |
| `double precision` `float8` | Числа от 1E-307 до 1E+308                                             | Занимает 8 байт.                                                                                                                                               |
| `serial`                    | Автоинкрементирующееся числовые значения от 1 до 2147483647           | Занимает 4 байта. Значение для данного типа подбираются автоматом в зависимости от значений предыдущего элемента. Отлично подходит для уникальных ID.          |
| `smallserial`               | Автоинкрементирующееся числовые значения от 1 до 32767                | Занимает 2 байта.                                                                                                                                              |
| `bigserial`                 | Автоинкрементирующееся числовые значения от 1 до 9223372036854775807  | Занимает 8 байт.                                                                                                                                               |

#### Символьные типы

| Тип                           | Значения                   | Описание                                                                                                               |
| :---------------------------- | :------------------------- | :--------------------------------------------------------------------------------------------------------------------- |
| `character` `char`            | Строки фиксированной длины | Принимает параметр, который задает количество символов в строке. <br> _char(5) – hello_                                |
| `character varying` `varchar` | Строки переменной длины    | Принимает параметр, который задает **максимальное** количество символов в строке. <br> _varchar(5) – abc, abcd, abcde_ |
| `text`                        | Текст произвольной длины   | Подойдет для хранения текста статей, отзывов, описаний.                                                                |

#### Дата и время

| Тип                        | Значения                                                                      | Описание          |
| :------------------------- | :---------------------------------------------------------------------------- | :---------------- |
| `timestamp`                | Дата и вермя от 4713 г до н.э до 294276 г н.э.                                | Занимает 8 байт.  |
| `timestamp with time zone` | Дата и вермя от 4713 г до н.э до 294276 г н.э. включая данные о часовом поясе | Занимает 8 байт.  |
| `date`                     | Дата от 4713 г. до н.э. до 5874897 г н.э.                                     | Занимает 4 байта. |
| `time`                     | Время от 00:00:00 до 24:00:00                                                 | Занимает 8 байт.  |
| `time with time zone`      | Время от 00:00:00+1459 до 24:00:00-1459.                                      | Занимает 12 байт. |

#### Геометрические типы

| Тип       | Значения                                        | Описание              |
| :-------- | :---------------------------------------------- | :-------------------- |
| `point`   | Точка формата (x,y)                             | Занимает 16 байт.     |
| `line`    | Линия в формате {A,B,C}                         | Занимает 32 байта.    |
| `lseg`    | Отрезок в формате ((x1,y1),(x2,y2))             | Занимает 32 байта.    |
| `box`     | Прямоугольник в формате ((x1,y1),(x2,y2))       | Занимает 32 байта.    |
| `path`    | Набор соединенных точек в формате ((x1,y1),...) | Занимает 16+16n байт. |
| `polygon` | Многоугольник в формате ((x1,y1),...).          | Занимает 40+16n байт. |
| `circle`  | Окружность в формате <(x,y),r>                  | Занимает 24 байта.    |

#### Другие

| Тип       | Значения                                                 | Описание                                                                                                                                            |
| :-------- | :------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- |
| `boolean` | true / false                                             | Вместо true можно указывать следующие значения: TRUE, 't', 'true', 'y', 'yes', 'on', '1'. Вместо FALSE: FALSE, 'f', 'false', 'n', 'no', 'off', '0'. |
| `bytea`   | Данные в виде бинарных строк                             |                                                                                                                                                     |
| `json`    | JSON в текстовом виде                                    |                                                                                                                                                     |
| `jsonb`   | JSON в бинарном формате                                  |                                                                                                                                                     |
| `uuid`    | Хранит строки [UUID](https://ru.wikipedia.org/wiki/UUID) |                                                                                                                                                     |
| `xml`     | Данные в формате XML                                     |                                                                                                                                                     |

### Атрибуты

Атрибуты позволяют указать дополнительные свойства для столбцов таблицы.

-   `PRIMARY KEY` – указывает, что столбец хранит уникальный идентификатор.

```sql
CREATE TABLE test (
    id SERIAL PRIMARY KEY
);
```

-   `UNIQUE` – указывает, что каждый элемент в столбце будет уникальным.

```sql
CREATE TABLE emails (
    email VARCHAR(50) UNIQUE
);
```

-   `NULL` – указывает, что значение в столбце может отсутствовать. (По умолчанию, все столбцы, кроме `PRIMARY KEY`, допускают отсутствие значений, поэтому явно его указывать не нужно.)

-   `NOT NULL` – указывает, что значение в столбце не может быть пустым.

```sql
CREATE TABLE users (
    firstName VARCHAR(30) NOT NULL,
    lastName VARCHAR(30) NOT NULL
);
```

-   `DEFAULT` – указывает значение, которое будет присваиваться по умолчанию.

```sql
CREATE TABLE messages (
    text VARCHAR(200) DEFAULT 'Hello World'
);
```

-   `CHECK` – указывает диапазон значений, которые могут храниться в столбце.

```sql
CREATE TABLE users (
    firstName VARCHAR(50),
    age INTEGER NOT NULL CHECK(age > 0 AND age < 100)
);
```

### Добавление данных

```sql
INSERT INTO clients (firstName, lastName, age, gender, isMarried)
    VALUES ('Alex', 'Smith', 25, 'male', false);
```

Можно вставлять сразу несколько элементов, перечисляя значения для нового элемента в новых скобках:

```sql
INSERT INTO messages (title, body) VALUES
    ('MSG-1', 'Hello World'),
    ('MSG-2', 'SQL is awesome'),
    ('MSG-3', 'Have a nice day!');
```

### Выборка данных

> Помните, что многие операторы можно комбинировать друг с другом.

Получить все элементы таблицы со значениями всех её столбцов:

```sql
SELECT * FROM clients;
```

Получить все элементы таблицы со значениями определенных столбцов:

```sql
SELECT firstName, lastName, phone FROM clients;
```

Получить первые `20` элементов таблицы:

```sql
SELECT * FROM clients LIMIT 20;
```

Получить первые `10` элементов таблицы начиная с позиции `50` (пагинация):

```sql
SELECT * FROM clients LIMIT 10 OFFSET 50;
```

Получить все элементы, где столбец `gender` равен значению "male":

```sql
SELECT * FROM clients WHERE gender = 'male';
```

Получить все элементы, где столбец `age` равен 25 и столбец `isMarried` равен false:

```sql
SELECT * FROM clients WHERE age = 25 AND isMarried = false;
```

Получить все элементы, где столбец `firstName` равен "Alex" или столбец `lastName` равен "Smith":

```sql
SELECT * FROM clients WHERE firstName = 'Alex' OR lastName = 'Smith';
```

Получить все элементы таблицы, где столбец `firstName` может иметь одно из перечисленных значений: "John", "Mike", "Kane":

```sql
SELECT * FROM clients WHERE firstName IN ('John', 'Mike', 'Kane');
```

Получить все элементы, где значения столбца `age` находятся в диапазоне от 20 до 30:

```sql
SELECT * FROM clients WHERE age BETWEEN 20 AND 30;
```

Получить все элементы, где значения столбца `phone` не являются пустыми:

```sql
SELECT * FROM clients WHERE phone IS NOT NULL;
```

Получить все значения столбца `lastName` без повторений (то есть, только уникальные значения):

```sql
SELECT DISTINCT(lastName) FROM clients;
```

### Поиск данных по шаблону

Для поиска данных по шаблонам используются операторы `LIKE` и `NOT LIKE`.
В самих шаблонах использются специальные подстановочные знаки:

-   `%` – подстановочный знак, который указывает, что на его месте может быть любое кол-во символов.
-   `_` – подстановочный знак, который указывает, что на его месте может быть только один символ.

Получить все элементы таблицы, где значение столбца `firstName` начинается с символа "A":

```sql
SELECT * FROM clients WHERE firstName LIKE 'A%';
```

Получить все элементы таблицы, где значение столбца `firstName` начинается с одного из перечисленных символов: "A", "B", "C":

```sql
SELECT * FROM clients WHERE firstName LIKE '[ABC]%';
```

Получить все элементы таблицы, где 2-ой символ в значении столбца `firstName` не равен символу "o":

```sql
SELECT * FROM clients WHERE firstName NOT LIKE '_o%';
```

### Сортировка данных

Получить все элементы таблицы отсортированные по столбцу `firstName` в порядке возрастания:

```sql
SELECT * FROM clients ORDER BY firstName ASC;
```

Получить все элементы таблицы отсортированные по столбцу `age` в порядке убывания:

```sql
SELECT * FROM clients ORDER BY age DESC;
```

Получить все элементы таблицы отсортированные по столбцу `lastName` в порядке убывания, а затем по столбцу `id` в порядке возрастания:

```sql
SELECT * FROM clients ORDER BY lastName DESC, id ASC;
```

### Изменение данных

Изменить значение столбца `phone` у элемента со значением столбца `id` равным 42:

```sql
UPDATE clients SET phone = '+123987654' WHERE id = 42;
```

Изменить значения столбцов `city` и `age` у элементов со значением столбцов `gender` = "female" и `name` = "Sophia":

```sql
UPDATE clients SET city = 'Paris', age = 33 WHERE gender = 'famale' AND name = "Sophia";
```

### Удаление данных

Удалить элемент из таблицы, где значение столбца `id` = 1:

```sql
DELETE FROM clients WHERE id = 137;
```

Удалить элементы из таблицы, где значения столбцов `city` = "Prague" и `age` = 22:

```sql
DELETE FROM clients WHERE city = 'Prague' AND age = 22;
```

### Псевдонимы

```sql
SELECT first_name AS name, last_name AS surname FROM clients;
```

```sh
    name     | surname
-------------+----------
 Fowler      | Ebbutt
 Huntley     | Giabucci
 Michel      | Cogman
 Bartholomew | Mecco
 Donelle     | Lambin
```

### Изменение таблиц

Добавить новый столбец `city` в таблицу `clients`:

```sql
ALTER TABLE clients ADD COLUMN city VARCHAR(50);
```

Удалить столбец `isMarried` из таблицы `clients`:

```sql
ALTER TABLE clients DROP COLUMN isMarried;
```

Переименовать столбец `firstName` в `fName` в таблицe `clients`:

```sql
ALTER TABLE clients RENAME COLUMN firstName TO fName;
```

Переименовать таблицу `clients` в `users`

```sql
ALTER TABLE clients RENAME TO users;
```

### Агрегатные функции

Агрегатные (_aggregate – совокупный_) функции используются для обобщения/подсчета данных.

Подсчитать общее количество элементов в таблице:

```sql
SELECT COUNT(*) FROM clients;
```

Получить максимальное/минимальное значение столбца `age`:

```sql
SELECT MAX(age) FROM clients;
```

```sql
SELECT MIN(age) FROM clients;
```

Подсчитать общую сумму всех элементов столбца `age`:

```sql
SELECT SUM(age) FROM clients;
```

Подсчитать среднее значение элементов столбца `age`:

```sql
SELECT AVG(age) FROM clients;
```

### Группировка данных

Сгруппировать данные из таблицы `clients` по столбцу `gender` и вывести в столбец `total` общее количество элементов для каждого значения `gender`:

```sql
SELECT gender, COUNT(gender) AS total FROM clients GROUP BY gender;
```

> Вместо названия столбца по которому идёт группировка, можно указать его порядковый номер в операторе `SELECT`:

```sql
SELECT gender, COUNT(gender) AS total FROM clients GROUP BY 1; # Аналогично запросу выше
```

```sh
   gender    | total
-------------+-------
 Male        |   368
 Female      |   245
```

Сгруппировать данные из таблицы `clients` по столбцу `gender`, а затем по столбцу `age`, вывести для каждого полученного элемента среднее значение столбца `balance` и отсортировать всё в порядке возрастания по столбцу `age`:

```sql
SELECT gender, age, AVG(balance) AS avg_money FROM clients GROUP BY gender, age ORDER BY age;
```

```sh
   gender    | age |       avg_money
-------------+-----+------------------------
 Male        |  18 |     31699.250000000000
 Female      |  18 |     21025.000000000000
 Male        |  19 |     16963.166666666667
 Female      |  19 |     25118.400000000000
 Male        |  20 |     23203.500000000000
 Female      |  20 |     22956.875000000000
 Male        |  21 |     19032.400000000000
 Female      |  21 |     27047.800000000000
```

## Индексы

Данные в таблицах хранятся в неупорядоченном виде (по сути в таком порядке, в котором они туда и попадают). Из-за этого, когда таблица наполняется большим объемом данных, различные операции по выборке, поиску или группировке данных начинают занимать все больше времени. Для решения этой проблемы существуют индексы. Индексы – это структура данных, которая хранит в себе ссылки на строки таблицы. Записи в индексе хранятся в отсортированном виде, что значительно ускоряет поиск.

### Создание индекса

При создании индекса указывается его название, таблица и столбец для которого создается индекс:

```sql
CREATE INDEX first_name_index ON clients (firstName);
```

> Название можно опускать, оно будет создано автоматически.

> Создание индекса для большой таблицы может занимать много времени. По умолчанию PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы `SELECT`) таблицы, но операции записи (`INSERT`, `UPDATE` и `DELETE`) блокируются до окончания построения индекса. Если для вашей системы это не допустипо, можете почитать об [неблокирующем построении индексов](https://postgrespro.ru/docs/postgresql/15/sql-createindex#SQL-CREATEINDEX-CONCURRENTLY).

Для столбцов с хранящих уникальные значениями не нужно вручную создавать отдельные индексы — они просто продублируют индексы, созданные автоматически.

Когда индекс уже создан, о его поддержании в актуальном состоянии заботится СУБД. Следует учитывать, что на это будут расходоваться некоторые ресурсы.


### Удаление индекса 

Индексы, которые используются в запросах редко или вообще никогда, должны быть удалены, чтобы не тратить ресурсы на их поддержание.

```sql
DROP INDEX first_name_index;
```

> Добавлять и удалять индексы можно в любое время.

### Типы индексов

В разных СУБД можно создавать индексы различных типов, но по умолчанию используется так называемое B-дерево. Такой индекс наиболее универсален и подходит для большинства типовых задач. Другие индексы необходимо использовать если Вы понимаете зачем.

-   [B-Tree](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPES-BTREE) - самый универсальный.
-   [Hash](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPES-BTREE) - эффективен только для простых операций с проверками на равенство.
-   [GiST](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPES-BTREE) - позволяет создавать пользовательские типы индексов и обеспечивает эффективное индексирование для сложных структур данных или полнотекстового поиска.
-   [SP-GiST](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPE-SPGIST) - продвинутая версия GiST.
-   [GIN](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPES-GIN) - предназначен для полнотекстового поиска и составных значений.
-   [BRIN](https://postgrespro.ru/docs/postgresql/15/indexes-types#INDEXES-TYPES-BRIN) - позволяет эффективно сканировать и запрашивать большие наборы данных из больших отсортированных таблиц.

Чтобы создать индекс определенного типа, необходимо использовать оператор `USING`:

```sql
CREATE INDEX email_index ON clients USING HASH (email);
```

### Составные индексы

Индексы можно создавать по нескольким столбцам таблицы. Например, в таблице клиентов мы часто делаем поиск в связке полей `firstName` и `lastName`. Для оптимизации такого поиска мы можем создать составной индекс:

```sql
CREATE INDEX fn_ln_index ON clients (firstName, lastName);
```

> Составными могут быть только индексы типов B-Tree, GiST, GIN и BRIN.

> Использовать такие индексы нужно без фанатизма. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.

### Индексы для выражений

Индекс можно создать для функции или скалярного выражения с одним или несколькими столбцами таблицы. 

Например, для таблицы `clients` столбцы `firstName` и `lastName` удобно использовать в связке, чтобы выполнять поиск по полному имени клиента. Для этого часто может использоватся операция конкатинации (объединения) и для которой полезно создать следующий индекс:

```sql
CREATE INDEX full_name_index ON clients ((firstName || ' ' || lastName));
```

Если часто приходится искать клиентов с определенным возрастом, то можно создать такой индекс:

```sql
CREATE INDEX young_clients_index ON clients (age) WHERE age = 18;
```